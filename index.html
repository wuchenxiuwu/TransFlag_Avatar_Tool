<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <!-- ç¦æ­¢ç¼©æ”¾ï¼Œçœå¾—ä¸çŸ¥é“çš„çå‡ æŠŠæ”¾å¤§ -->
    <title>å¤´åƒé±¼æ¿è·¨æ——æ·»åŠ å·¥å…· ğŸ¥ğŸ³ï¸â€âš§ï¸</title>
    <style>
        /* æ ·å¼å®Œå…¨ä¿ç•™ä¸Šæ¬¡çš„å“åº”å¼è®¾è®¡ï¼Œæ²¡åŠ¨è¿‡ï¼Œçœå¾—åˆä»–å¦ˆå‡ºå¹ºè›¾å­ */
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.15);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        .upload-section {
            margin-bottom: 30px;
            text-align: center;
            padding: 25px;
            border: 3px dashed #a0a0a0;
            border-radius: 12px;
            transition: all 0.3s;
            background-color: #f9f9f9;
        }
        .upload-section.drag-over {
            border-color: #007bff;
            background-color: #e6f7ff;
        }
        #avatarUpload {
            display: none; /* éšè—åŸå§‹inputï¼Œç”¨labelä¼ªè£…ä¸Šä¼ æŒ‰é’®ï¼Œæ“ï¼Œè¿™è®¾è®¡å€’æ˜¯æŒºèªæ˜ */
        }
        .upload-btn {
            display: inline-block;
            padding: 12px 25px;
            background-color: #4CAF50;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .upload-btn:hover {
            background-color: #45a049;
            transform: translateY(-1px);
        }
        .drag-tip {
            color: #666;
            margin-top: 5px;
        }
        .flag-selection-area {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
            text-align: center;
        }
        .flag-gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }
        .flag-item {
            cursor: pointer;
            border: 3px solid transparent;
            border-radius: 6px;
            overflow: hidden;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            background-color: white;
            text-align: center;
            padding: 5px;
            flex: 0 0 auto;
            width: 130px;
        }
        .flag-item.selected {
            border-color: #007bff;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.8);
            background-color: #e6f7ff;
        }
        .flag-item:hover:not(.selected) {
            border-color: #a0a0a0;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .flag-preview-img {
            width: 120px;
            height: 60px;
            object-fit: contain;
            display: block;
            margin: 0 auto;
        }
        .flag-name {
            font-size: 13px;
            margin-top: 5px;
            color: #555;
            word-break: keep-all;
        }

        /* é¢„è§ˆåŒºåŸŸï¼šå½»åº•å“åº”å¼ï¼Œç”¨gridä¸ç”¨flexäº†ï¼Œæ‰‹æœºç»ˆäºä¸ä»–å¦ˆæº¢å‡ºäº† */
        .preview-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            justify-items: center;
            margin-bottom: 30px;
        }

        .preview-item {
            text-align: center;
            width: 100%;
            max-width: 300px;
            padding: 10px;
            box-sizing: border-box;
        }

        .canvas-wrapper {
            width: 100%;
            max-width: 300px;
            aspect-ratio: 1 / 1; /* ä¿æŒæ­£æ–¹å½¢ï¼Œä¸ç®¡å±å¹•å¤šå®½ */
            margin: 0 auto;
            border: 2px solid #ddd;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #eee;
            position: relative;
            touch-action: none; /* ç¦æ­¢æµè§ˆå™¨é»˜è®¤æ‰‹åŠ¿ï¼Œæ“ï¼Œæ—©è¯¥åŠ è¿™ä¸ª */
        }

        .canvas-wrapper canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .canvas-wrapper[data-has-image="false"] {
            border: 4px dashed #a0a0a0;
            background-color: #e0e0e0;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
        }

        #circularWrapper {
            border-radius: 50%;
        }

        #circularCanvas {
            border-radius: 50%;
            border: 2px solid #007bff;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.2);
        }

        #imageCanvas, #circularCanvas {
            cursor: pointer;
            touch-action: none; /* ç”»å¸ƒä¹Ÿè¦ç¦æ­¢æ‰‹åŠ¿ï¼Œä»¥é˜²ä¸‡ä¸€ */
        }

        .flag-controls {
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .control-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 5px 0;
        }
        .control-group label {
            font-weight: bold;
            color: #555;
            min-width: 50px;
        }
        .control-group input[type="range"] {
            flex-grow: 1;
            margin: 0 10px;
        }
        .control-group input[type="number"] {
            width: 70px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
        }
        .control-group button {
            padding: 8px 15px;
            background-color: #ff9800;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .control-group button:hover {
            background-color: #e68900;
        }
        #downloadBtn {
            background-color: #007bff;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: bold;
            transition: all 0.3s ease;
            display: block;
            margin: 30px auto;
            box-shadow: 0 4px 10px rgba(0, 123, 255, 0.3);
        }
        #downloadBtn:hover:not(:disabled) {
            background-color: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 123, 255, 0.4);
        }
        #downloadBtn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .main-footer {
            margin-top: 40px;
            padding: 20px 0;
            text-align: center;
            border-top: 1px solid #ddd;
            color: #666;
            font-size: 14px;
        }
        .contributor-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
        }
        .contributor-item {
            display: inline-flex;
            align-items: center;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            transition: background-color 0.3s;
        }
        .contributor-item:hover {
            background-color: #e0e0e0;
        }
        .contributor-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid #4CAF50;
            vertical-align: middle;
        }
        .contributor-login {
            color: #333;
            text-decoration: none;
            transition: color 0.3s;
        }
        .contributor-login:hover {
            color: #4CAF50;
            text-decoration: underline;
        }
        .main-footer p a {
            color: #4CAF50;
            text-decoration: none;
            font-weight: bold;
        }
        .main-footer p a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>å¤´åƒé±¼æ¿è·¨æ——æ·»åŠ å·¥å…· ğŸ¥ğŸ³ï¸â€âš§ï¸</h1>

        <div class="upload-section" id="dropArea">
            <input type="file" id="avatarUpload" accept="image/*">
            <label for="avatarUpload" class="upload-btn">ä¸Šä¼ å¤´åƒ</label>
            <span id="fileName"></span>
            <p class="drag-tip">æˆ–å°†å›¾ç‰‡æ‹–æ”¾åˆ°æ­¤å¤„</p>
        </div>

        <div class="flag-selection-area">
            <h2>é€‰æ‹©æ——å¸œæ¨¡æ¿</h2>
            <div id="flagGallery" class="flag-gallery"></div>
        </div>

        <div class="preview-container">
            <div class="preview-item">
                <h3>åŸå§‹å¤´åƒ</h3>
                <div class="canvas-wrapper" id="originalWrapper" data-has-image="false">
                    <canvas id="originalCanvas" width="300" height="300"></canvas>
                </div>
                <div class="flag-controls-info">
                    <p style="font-size: 14px; color: #555;">ç‚¹å‡»å³ä¾§é¢„è§ˆåŒºè¿›è¡Œæ——å¸œçš„ç¼–è¾‘</p>
                </div>
            </div>

            <div class="preview-item">
                <h3>é¢„è§ˆå¤„ç†å¤´åƒ-æ–¹</h3>
                <div class="canvas-wrapper" id="imageWrapper" data-has-image="false">
                    <canvas id="imageCanvas" width="300" height="300"></canvas>
                </div>
                <div class="flag-preview"></div> <!-- æ§åˆ¶é¢æ¿ä¼šåŠ¨æ€æ’å…¥æ­¤å¤„ï¼Œåˆ«ä¹±åŠ¨ -->
            </div>

            <div class="preview-item">
                <h3>é¢„è§ˆå¤„ç†å¤´åƒ-åœ†</h3>
                <div class="canvas-wrapper" id="circularWrapper" data-has-image="false">
                    <canvas id="circularCanvas" width="300" height="300"></canvas>
                </div>
            </div>
        </div>

        <button id="downloadBtn" disabled>ä¸‹è½½å¤„ç†åçš„å¤´åƒ</button>

        <footer class="main-footer">
            <div id="contributorsContainer"></div>
            <p>é¡¹ç›®ä»“åº“ï¼š<a href="https://github.com/bghtnya/TransFlag_Avatar_Tool/" target="_blank">TransFlag_Avatar_Tool</a></p>
        </footer>
    </div>

    <script>
        (function() {
            // ---------- é…ç½®æ•°æ® ----------
            // å¦ˆçš„ï¼Œæ¨¡æ¿æ•°æ®å°±è¿™å‡ è¡Œï¼Œç»™è€å­çœ‹å¥½äº†
            const FLAG_TEMPLATES = [
                { key: 'bottom_trans', name: 'åº•éƒ¨é±¼æ¿è·¨æ——', defaultScale: 1.2, aspectRatio: 2 }, // keyæ˜¯è‹±æ–‡ï¼Œnameæ˜¾ç¤ºç”¨ï¼ŒaspectRatioæ˜¯å®½é«˜æ¯”ï¼Œæ²¡å›¾ç‰‡æ—¶é è¿™ä¸ªç”»æ¡†
                { key: 'bottom_transles', name: 'åº•éƒ¨è·¨ Les é±¼æ¿', defaultScale: 1.2, aspectRatio: 2 },
                { key: 'bottom_les', name: 'åº•éƒ¨ Les é±¼æ¿', defaultScale: 1.2, aspectRatio: 2 },
                { key: 'right_bottom_trans', name: 'å³ä¸‹é±¼æ¿è·¨æ——', defaultScale: 1.0, aspectRatio: 2 },
                { key: 'right_bottom_les', name: 'å³ä¸‹ Les é±¼æ¿', defaultScale: 1.0, aspectRatio: 2 },
                { key: 'right_bottom_transles', name: 'å³ä¸‹è·¨ Les é±¼æ¿', defaultScale: 1.0, aspectRatio: 2 },
            ];

            // ---------- è·¯å¾„æ¢æµ‹å‡½æ•°----------
            // è¿™å‡½æ•°ä»–å¦ˆçš„æ˜¯ä¸ºäº†é‚£äº›æŠŠå›¾ç‰‡æ”¾å¾—åˆ°å¤„éƒ½æ˜¯çš„å‚»é€¼AI
            function loadFlagImage(flagKey, callback) {
                // ä¸­æ–‡æ–‡ä»¶åæ˜ å°„è¡¨ï¼Œå› ä¸ºåŸé¡¹ç›®ç”¨ä¸­æ–‡å‘½åï¼Œæ“
                const nameMap = {
                    bottom_trans: 'åº•éƒ¨é±¼æ¿è·¨æ——æ¨¡æ¿.png',
                    bottom_transles: 'åº•éƒ¨translesé±¼æ¿.png',
                    bottom_les: 'åº•éƒ¨lesé±¼æ¿.png',
                    right_bottom_trans: 'å³ä¸‹é±¼æ¿è·¨æ——æ¨¡æ¿.png',
                    right_bottom_les: 'å³ä¸‹lesé±¼æ¿.png',
                    right_bottom_transles: 'å³ä¸‹translesé±¼æ¿.png'
                };
                const filename = nameMap[flagKey]; // å–ä¸­æ–‡åï¼Œæ²¡æœ‰å°±æ»š
                if (!filename) {
                    console.warn(`æœªæ‰¾åˆ°æ˜ å°„çš„æ–‡ä»¶å: ${flagKey}`); // è­¦å‘Šï¼Œä½†åˆ«ä»–å¦ˆå´©æºƒ
                    callback(null);
                    return;
                }
                const possiblePaths = [ // æŒ¨ä¸ªç›®å½•è¯•ï¼Œè·Ÿç‰¹ä¹ˆå¯»å®ä¼¼çš„
                    filename, // å½“å‰ç›®å½•
                    `./res/${filename}`, // reså­ç›®å½•
                    `../res/${filename}`, // ä¸Šçº§res
                    `/res/${filename}` // æ ¹ç›®å½•res
                ];

                let index = 0;
                function tryNext() { // é€’å½’è¯•è·¯å¾„ï¼Œå¦ˆçš„åƒä¸ªå‚»é€¼ä¸€æ ·
                    if (index >= possiblePaths.length) {
                        console.warn(`æ‰€æœ‰è·¯å¾„åŠ è½½å¤±è´¥: ${filename}`); // å…¨æ²¡äº†ï¼Œç”¨æˆ·è‡ªå·±çœ‹ç€åŠ
                        callback(null);
                        return;
                    }
                    const path = possiblePaths[index++];
                    const img = new Image();
                    img.onload = () => callback(img); // æˆäº†
                    img.onerror = tryNext; // å¤±è´¥äº†ç»§ç»­è¯•ä¸‹ä¸€ä¸ª
                    img.src = path;
                }
                tryNext();
            }

            // ---------- æ ¸å¿ƒç¼–è¾‘å™¨ç±» ----------
            // æŠŠæ‰€æœ‰é€»è¾‘ä»–å¦ˆçš„å…¨å¡è¿›è¿™ä¸ªç±»é‡Œï¼Œçœå¾—å…¨å±€å˜é‡æ»¡å¤©é£
            class FlagAvatarEditor {
                constructor() {
                    this.CANVAS_SIZE = 300; // é¢„è§ˆç”»å¸ƒå¤§å°ï¼Œå›ºå®š300x300
                    this.FLAG_SIZE_RATIO = 0.9; // æ——å¸œå å¤´åƒçŸ­è¾¹çš„æ¯”ä¾‹ï¼Œåˆ«é—®æˆ‘ä¸ºä»€ä¹ˆæ˜¯0.9ï¼ŒåŸé¡¹ç›®å°±è¿™ä¹ˆå®šçš„

                    this.originalImage = null; // åŸå§‹å¤´åƒå›¾ç‰‡
                    this.flagImage = null; // å½“å‰æ——å¸œå›¾ç‰‡ï¼ˆå¯èƒ½ä¸ºnullï¼‰
                    this.currentFlagKey = FLAG_TEMPLATES[0].key; // é»˜è®¤ç¬¬ä¸€ä¸ªæ——å¸œ
                    this.originalFileName = 'avatar'; // ä¸‹è½½æ—¶çš„æ–‡ä»¶å

                    this.flagOffset = { x: 0, y: 0 }; // æ——å¸œåç§»é‡ï¼Œç›¸å¯¹äºé»˜è®¤ä½ç½®
                    this.flagScale = 1.0; // ç¼©æ”¾å€æ•°
                    this.flagRotation = 0; // æ—‹è½¬è§’åº¦ï¼Œ0-360

                    this.processCanvas = document.createElement('canvas'); // ç¦»å±ç”»å¸ƒï¼Œå­˜åŸå§‹åˆ†è¾¨ç‡å›¾åƒ
                    this.processCtx = this.processCanvas.getContext('2d');

                    // DOM å…ƒç´ ï¼Œå…¨ä»–å¦ˆæŠ“å‡ºæ¥
                    this.avatarUpload = document.getElementById('avatarUpload');
                    this.fileNameSpan = document.getElementById('fileName');
                    this.dropArea = document.getElementById('dropArea');
                    this.flagGallery = document.getElementById('flagGallery');
                    this.originalCanvas = document.getElementById('originalCanvas');
                    this.imageCanvas = document.getElementById('imageCanvas');
                    this.circularCanvas = document.getElementById('circularCanvas');
                    this.originalWrapper = document.getElementById('originalWrapper');
                    this.imageWrapper = document.getElementById('imageWrapper');
                    this.circularWrapper = document.getElementById('circularWrapper');
                    this.downloadBtn = document.getElementById('downloadBtn');
                    this.contributorsContainer = document.getElementById('contributorsContainer');

                    this.originalCtx = this.originalCanvas.getContext('2d');
                    this.imageCtx = this.imageCanvas.getContext('2d');
                    this.circularCtx = this.circularCanvas.getContext('2d');

                    this.controlPoints = {}; // æ§åˆ¶ç‚¹åæ ‡ï¼Œç”¨äºé¼ æ ‡æ“ä½œ
                    this.activeControl = null; // å½“å‰æ¿€æ´»çš„æ§åˆ¶ç‚¹
                    this.isDragging = false; // é¼ æ ‡æ˜¯å¦åœ¨æ‹–åŠ¨
                    this.lastMouse = { x: 0, y: 0 }; // ä¸Šæ¬¡é¼ æ ‡ä½ç½®
                    this.dragStartState = { flagOffset: { x:0, y:0 }, flagScale:1.0, flagRotation:0 }; // æ‹–åŠ¨å¼€å§‹æ—¶çš„çŠ¶æ€

                    // è§¦æ‘¸ä¸“ç”¨çŠ¶æ€ï¼ˆå®Œå…¨ç‹¬ç«‹ï¼‰ï¼Œçœå¾—è·Ÿé¼ æ ‡æ··åœ¨ä¸€èµ·å‡ºå¹ºè›¾å­
                    this.touchActive = false;          // æ˜¯å¦æ­£åœ¨è§¦æ‘¸æ‹–åŠ¨
                    this.touchCanvas = null;            // è§¦å‘è§¦æ‘¸çš„ç”»å¸ƒ
                    this.touchLast = { x:0, y:0 };      // ä¸Šä¸€æ¬¡è§¦æ‘¸ç‚¹ï¼ˆé¢„è§ˆåæ ‡ï¼‰

                    this.history = []; // å†å²è®°å½•æ•°ç»„ï¼Œç”¨äºæ’¤é”€é‡åš
                    this.historyIndex = -1; // å½“å‰å†å²ç´¢å¼•
                    this.maxHistory = 20; // æœ€å¤šå­˜20æ­¥
                    this.saveTimer = null; // å»¶è¿Ÿä¿å­˜å®šæ—¶å™¨

                    // ç»‘å®šthisï¼Œçœå¾—å›è°ƒé‡Œæä¸¢
                    this.handleFileChange = this.handleFileChange.bind(this);
                    this.handleDrop = this.handleDrop.bind(this);
                    this.handleDragOver = this.handleDragOver.bind(this);
                    this.handleDragLeave = this.handleDragLeave.bind(this);
                    this.handleFlagSelect = this.handleFlagSelect.bind(this);
                    this.handleMouseDown = this.handleMouseDown.bind(this);
                    this.handleMouseMove = this.handleMouseMove.bind(this);
                    this.handleMouseUp = this.handleMouseUp.bind(this);
                    this.handleTouchStart = this.handleTouchStart.bind(this);
                    this.handleTouchMove = this.handleTouchMove.bind(this);
                    this.handleTouchEnd = this.handleTouchEnd.bind(this);
                    this.handleTouchCancel = this.handleTouchEnd.bind(this);
                    this.handleKeyDown = this.handleKeyDown.bind(this);
                    this.handleScaleInput = this.handleScaleInput.bind(this);
                    this.handleRotationInput = this.handleRotationInput.bind(this);
                    this.resetTransform = this.resetTransform.bind(this);
                    this.downloadImage = this.downloadImage.bind(this);

                    this.init(); // å¯åŠ¨
                }

                init() {
                    this.renderFlagGallery(); // ç”»æ——å¸œé€‰æ‹©å™¨

                    // åŠ è½½é»˜è®¤æ——å¸œ
                    loadFlagImage(this.currentFlagKey, (img) => {
                        if (img) this.flagImage = img;
                        else console.warn('é»˜è®¤æ——å¸œåŠ è½½å¤±è´¥'); // åŠ è½½ä¸äº†å°±ç®—äº†ï¼Œåæ­£åé¢æœ‰è™šæ‹Ÿæ¡†
                        if (this.originalImage) this.resetTransform(FLAG_TEMPLATES[0].defaultScale);
                        this.drawAll();
                    });

                    // äº‹ä»¶ç›‘å¬ï¼Œå¦ˆçš„ç»‘äº†ä¸€å †
                    this.avatarUpload.addEventListener('change', this.handleFileChange);
                    this.dropArea.addEventListener('dragover', this.handleDragOver);
                    this.dropArea.addEventListener('dragleave', this.handleDragLeave);
                    this.dropArea.addEventListener('drop', this.handleDrop);

                    this.imageCanvas.addEventListener('mousedown', this.handleMouseDown);
                    this.circularCanvas.addEventListener('mousedown', this.handleMouseDown);
                    document.addEventListener('mousemove', this.handleMouseMove);
                    document.addEventListener('mouseup', this.handleMouseUp);

                    // è§¦æ‘¸äº‹ä»¶ï¼ˆè¿™ä»–å¦ˆæ˜¯ç‹¬ç«‹çš„ï¼Œä¸è¦çæ”¹ï¼‰
                    this.imageCanvas.addEventListener('touchstart', this.handleTouchStart, { passive: false });
                    this.circularCanvas.addEventListener('touchstart', this.handleTouchStart, { passive: false });
                    document.addEventListener('touchmove', this.handleTouchMove, { passive: false });
                    document.addEventListener('touchend', this.handleTouchEnd);
                    document.addEventListener('touchcancel', this.handleTouchCancel);

                    document.addEventListener('keydown', this.handleKeyDown);

                    this.downloadBtn.addEventListener('click', this.downloadImage);

                    this.createControlPanel(); // åˆ›å»ºç¼©æ”¾æ—‹è½¬æ§åˆ¶é¢æ¿
                    this.fetchContributors(); // è·å–è´¡çŒ®è€…åˆ—è¡¨ï¼ˆè£…é€¼ç”¨ï¼‰
                }

                renderFlagGallery() {
                    this.flagGallery.innerHTML = ''; // æ¸…ç©º
                    FLAG_TEMPLATES.forEach(template => {
                        const item = document.createElement('div');
                        item.className = 'flag-item';
                        if (template.key === this.currentFlagKey) item.classList.add('selected');
                        item.dataset.key = template.key;
                        // é¢„è§ˆå›¾ï¼ŒåŠ è½½å¤±è´¥å°±æ˜¾ç¤º"å›¾ç‰‡åŠ è½½å¤±è´¥"çš„SVG
                        item.innerHTML = `
                            <img src="" alt="${template.name}" class="flag-preview-img" 
                                 data-flag-key="${template.key}"
                                 onerror="this.src='data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22120%22%20height%3D%2260%22%3E%3Crect%20width%3D%22120%22%20height%3D%2260%22%20fill%3D%22%23ccc%22%2F%3E%3Ctext%20x%3D%2210%22%20y%3D%2235%22%20font-size%3D%2212%22%20fill%3D%22%23333%22%3Eå›¾ç‰‡åŠ è½½å¤±è´¥%3C%2Ftext%3E%3C%2Fsvg%3E'">
                            <p class="flag-name">${template.name}</p>
                        `;
                        const imgEl = item.querySelector('img');
                        // å°è¯•åŠ è½½çœŸæ­£çš„å›¾ç‰‡
                        loadFlagImage(template.key, (img) => {
                            if (img) imgEl.src = img.src;
                        });
                        item.addEventListener('click', () => this.handleFlagSelect(template.key));
                        this.flagGallery.appendChild(item);
                    });
                }

                handleFlagSelect(key) {
                    if (key === this.currentFlagKey) return; // é€‰åŒä¸€ä¸ªå°±ç®—äº†
                    const template = FLAG_TEMPLATES.find(t => t.key === key);
                    if (!template) return;

                    loadFlagImage(key, (img) => {
                        if (img) {
                            this.flagImage = img; // å›¾ç‰‡åŠ è½½æˆåŠŸ
                        } else {
                            this.flagImage = null; // åŠ è½½å¤±è´¥ï¼Œç”¨è™šæ‹Ÿæ¡†
                            alert(`æ——å¸œå›¾ç‰‡â€œ${template.name}â€åŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨è™šæ‹Ÿæ¡†ï¼Œæ‚¨å¯ä»¥ç»§ç»­è°ƒæ•´ä½ç½®/ç¼©æ”¾/æ—‹è½¬ï¼Œä½†æ——å¸œå›¾æ¡ˆæš‚ä¸å¯è§ã€‚`);
                        }
                        this.currentFlagKey = key;
                        // æ›´æ–°é€‰ä¸­æ ·å¼
                        document.querySelectorAll('.flag-item').forEach(item => {
                            item.classList.toggle('selected', item.dataset.key === key);
                        });
                        this.resetTransform(template.defaultScale || 1.0); // é‡ç½®å˜æ¢åˆ°é»˜è®¤ç¼©æ”¾è¦æ˜¯æƒ³æ”¹ï¼Œå¯ä»¥æ”¹ä¸æ”¹ä¹‹å‰å»ºè®®æ‚é‡æ‚é‡è¿™AIçš„å®åŠ›ï¼Œåˆ«ä»–å¦ˆåˆ°æ—¶å€™åˆæ•´å‡ºå¹ºè›¾å­äº†
                        this.saveState();
                    });
                }

                createControlPanel() {
                    const container = document.querySelector('.flag-preview');
                    if (!container) return;
                    const panel = document.createElement('div');
                    panel.className = 'flag-controls';
                    // æ»‘å—å’Œè¾“å…¥æ¡†ï¼Œç¼©æ”¾0.5-3.0ï¼Œæ—‹è½¬0-360
                    panel.innerHTML = `
                        <div class="control-group">
                            <label>ç¼©æ”¾ï¼š</label>
                            <input type="range" id="scaleSlider" min="0.5" max="3.0" step="0.1" value="1.0">
                            <input type="number" id="scaleInput" min="0.5" max="3.0" step="0.1" value="1.0">
                        </div>
                        <div class="control-group">
                            <label>æ—‹è½¬ï¼š</label>
                            <input type="range" id="rotationSlider" min="0" max="360" step="1" value="0">
                            <input type="number" id="rotationInput" min="0" max="360" step="1" value="0">
                        </div>
                        <div class="control-group" style="justify-content: center;">
                            <button id="resetBtn">é‡ç½®</button>
                        </div>
                    `;
                    container.appendChild(panel);

                    this.scaleSlider = document.getElementById('scaleSlider');
                    this.scaleInput = document.getElementById('scaleInput');
                    this.rotationSlider = document.getElementById('rotationSlider');
                    this.rotationInput = document.getElementById('rotationInput');
                    this.resetBtn = document.getElementById('resetBtn');

                    this.scaleSlider.addEventListener('input', this.handleScaleInput);
                    this.scaleInput.addEventListener('input', this.handleScaleInput);
                    this.rotationSlider.addEventListener('input', this.handleRotationInput);
                    this.rotationInput.addEventListener('input', this.handleRotationInput);
                    this.resetBtn.addEventListener('click', () => {
                        const template = FLAG_TEMPLATES.find(t => t.key === this.currentFlagKey);
                        this.resetTransform(template ? template.defaultScale : 1.0);
                    });
                }

                handleScaleInput(e) {
                    let val = parseFloat(e.target.value);
                    if (isNaN(val)) return;
                    val = Math.min(3.0, Math.max(0.5, val)); // é™åˆ¶èŒƒå›´
                    this.flagScale = val;
                    this.scaleSlider.value = val;
                    this.scaleInput.value = val.toFixed(2);
                    this.drawAll();
                    this.deferredSaveState();
                }

                handleRotationInput(e) {
                    let val = parseFloat(e.target.value);
                    if (isNaN(val)) return;
                    val = Math.min(360, Math.max(0, val)); // é™åˆ¶0-360
                    this.flagRotation = val;
                    this.rotationSlider.value = val;
                    this.rotationInput.value = val;
                    this.drawAll();
                    this.deferredSaveState();
                }

                resetTransform(scale = 1.0) {
                    this.flagOffset = { x: 0, y: 0 };
                    this.flagScale = scale;
                    this.flagRotation = 0;
                    this.scaleSlider.value = scale;
                    this.scaleInput.value = scale.toFixed(2);
                    this.rotationSlider.value = 0;
                    this.rotationInput.value = 0;
                    this.drawAll();
                    this.saveState();
                }

                handleFileChange(e) {
                    const file = e.target.files[0];
                    if (file) this.loadImageFromFile(file);
                }

                handleDragOver(e) {
                    e.preventDefault();
                    this.dropArea.classList.add('drag-over');
                }

                handleDragLeave(e) {
                    e.preventDefault();
                    this.dropArea.classList.remove('drag-over');
                }

                handleDrop(e) {
                    e.preventDefault();
                    this.dropArea.classList.remove('drag-over');
                    const file = e.dataTransfer.files[0];
                    if (file && file.type.startsWith('image/')) {
                        this.loadImageFromFile(file);
                    } else {
                        alert('è¯·æ‹–æ”¾å›¾ç‰‡æ–‡ä»¶');
                    }
                }

                loadImageFromFile(file) {
                    this.fileNameSpan.textContent = file.name;
                    this.originalFileName = file.name.replace(/\.[^/.]+$/, ""); // å»æ‰æ‰©å±•å
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            this.originalImage = img;
                            this.processCanvas.width = img.width;
                            this.processCanvas.height = img.height;
                            this.updateWrappers(true);
                            this.downloadBtn.disabled = false;
                            const template = FLAG_TEMPLATES.find(t => t.key === this.currentFlagKey);
                            this.resetTransform(template ? template.defaultScale : 1.0);
                            this.saveState(true);
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }

                updateWrappers(hasImage) {
                    const val = hasImage ? 'true' : 'false';
                    this.originalWrapper.dataset.hasImage = val;
                    this.imageWrapper.dataset.hasImage = val;
                    this.circularWrapper.dataset.hasImage = val;
                }

                getPreviewTransform() {
                    if (!this.originalImage) return { scale: 1, offsetX: 0, offsetY: 0 };
                    // è®¡ç®—å¤´åƒåœ¨300x300ç”»å¸ƒä¸­çš„ç¼©æ”¾å’Œåç§»ï¼Œä¿æŒçºµæ¨ªæ¯”
                    const scale = Math.min(this.CANVAS_SIZE / this.originalImage.width, this.CANVAS_SIZE / this.originalImage.height);
                    const offsetX = (this.CANVAS_SIZE - this.originalImage.width * scale) / 2;
                    const offsetY = (this.CANVAS_SIZE - this.originalImage.height * scale) / 2;
                    return { scale, offsetX, offsetY };
                }

                previewToProcess(x, y) {
                    const t = this.getPreviewTransform();
                    return { x: (x - t.offsetX) / t.scale, y: (y - t.offsetY) / t.scale };
                }

                processToPreview(x, y) {
                    const t = this.getPreviewTransform();
                    return { x: x * t.scale + t.offsetX, y: y * t.scale + t.offsetY };
                }

                drawAll() {
                    // ç»˜åˆ¶ç¦»å±ç”»å¸ƒ
                    if (this.originalImage) {
                        this.processCtx.clearRect(0, 0, this.processCanvas.width, this.processCanvas.height);
                        this.processCtx.drawImage(this.originalImage, 0, 0);
                    }

                    // è®¡ç®—æ——å¸œå°ºå¯¸
                    const base = this.originalImage ? Math.min(this.originalImage.width, this.originalImage.height) : this.CANVAS_SIZE;
                    const flagBaseSize = base * this.FLAG_SIZE_RATIO;
                    let flagW, flagH;

                    if (this.flagImage && this.flagImage.complete && this.flagImage.naturalWidth > 0) {
                        // æœ‰å›¾ç‰‡ï¼ŒæŒ‰å›¾ç‰‡æ¯”ä¾‹
                        flagW = flagBaseSize * this.flagScale;
                        flagH = (this.flagImage.height / this.flagImage.width) * flagBaseSize * this.flagScale;
                    } else {
                        // æ²¡å›¾ç‰‡ï¼Œç”¨é¢„è®¾å®½é«˜æ¯”
                        const template = FLAG_TEMPLATES.find(t => t.key === this.currentFlagKey);
                        const aspect = template ? template.aspectRatio : 2;
                        flagW = flagBaseSize * this.flagScale;
                        flagH = flagW / aspect;
                    }

                    // è®¡ç®—é»˜è®¤ä½ç½®ï¼ˆä¸åŒæ——å¸œä½ç½®ä¸åŒï¼‰
                    let defaultX, defaultY;
                    if (this.currentFlagKey.startsWith('bottom')) {
                        defaultX = (this.originalImage.width - flagW) / 2;
                        defaultY = this.originalImage.height - flagH;
                    } else if (this.currentFlagKey.startsWith('right_bottom')) {
                        defaultX = this.originalImage.width - flagW;
                        defaultY = this.originalImage.height - flagH;
                    } else {
                        defaultX = (this.originalImage.width - flagW) / 2;
                        defaultY = (this.originalImage.height - flagH) / 2;
                    }

                    const flagX = defaultX + this.flagOffset.x;
                    const flagY = defaultY + this.flagOffset.y;
                    const flagCx = flagX + flagW / 2;
                    const flagCy = flagY + flagH / 2;

                    this.flagRect = { x: flagX, y: flagY, w: flagW, h: flagH, cx: flagCx, cy: flagCy };

                    // å¦‚æœæœ‰æ——å¸œå›¾ç‰‡ï¼Œç»˜åˆ¶åˆ°ç¦»å±ç”»å¸ƒæ²¡å›¾ç‰‡ï¼Œç›´æ¥æŠ¥é”™
                    if (this.flagImage && this.flagImage.complete && this.flagImage.naturalWidth > 0) {
                        this.processCtx.save();
                        this.processCtx.translate(flagCx, flagCy);
                        this.processCtx.rotate(this.flagRotation * Math.PI / 180);
                        this.processCtx.drawImage(this.flagImage, -flagW / 2, -flagH / 2, flagW, flagH);
                        this.processCtx.restore();
                    }

                    // æ›´æ–°ä¸‰ä¸ªé¢„è§ˆç”»å¸ƒ
                    this.updatePreviews();
                }

                updatePreviews() {
                    const t = this.getPreviewTransform();

                    // åŸå§‹å¤´åƒç”»å¸ƒï¼ˆåªæ˜¾ç¤ºå¤´åƒï¼‰
                    if (this.originalImage) {
                        this.originalCtx.clearRect(0, 0, this.CANVAS_SIZE, this.CANVAS_SIZE);
                        this.originalCtx.drawImage(this.originalImage, 0, 0, this.originalImage.width, this.originalImage.height, t.offsetX, t.offsetY, this.originalImage.width * t.scale, this.originalImage.height * t.scale);
                    } else {
                        this.originalCtx.clearRect(0, 0, this.CANVAS_SIZE, this.CANVAS_SIZE);
                    }

                    // æ–¹å½¢é¢„è§ˆç”»å¸ƒï¼ˆæ˜¾ç¤ºç¦»å±ç”»å¸ƒï¼‰
                    this.imageCtx.clearRect(0, 0, this.CANVAS_SIZE, this.CANVAS_SIZE);
                    if (this.originalImage) {
                        this.imageCtx.drawImage(this.processCanvas, 0, 0, this.processCanvas.width, this.processCanvas.height, t.offsetX, t.offsetY, this.originalImage.width * t.scale, this.originalImage.height * t.scale);
                    }

                    // åœ†å½¢é¢„è§ˆç”»å¸ƒ
                    this.circularCtx.clearRect(0, 0, this.CANVAS_SIZE, this.CANVAS_SIZE);
                    if (this.originalImage) {
                        this.circularCtx.save();
                        this.circularCtx.beginPath();
                        this.circularCtx.arc(this.CANVAS_SIZE/2, this.CANVAS_SIZE/2, this.CANVAS_SIZE/2, 0, 2*Math.PI);
                        this.circularCtx.clip();
                        this.circularCtx.drawImage(this.processCanvas, 0, 0, this.processCanvas.width, this.processCanvas.height, t.offsetX, t.offsetY, this.originalImage.width * t.scale, this.originalImage.height * t.scale);
                        this.circularCtx.restore();
                        // ç”»ä¸ªè¾¹æ¡†
                        this.circularCtx.beginPath();
                        this.circularCtx.arc(this.CANVAS_SIZE/2, this.CANVAS_SIZE/2, this.CANVAS_SIZE/2-1, 0, 2*Math.PI);
                        this.circularCtx.strokeStyle = '#007bff';
                        this.circularCtx.lineWidth = 2;
                        this.circularCtx.stroke();
                    }

                    // ç»˜åˆ¶æ§åˆ¶ç‚¹ï¼ˆè™šçº¿æ¡†å’Œæ‰‹æŸ„ï¼‰
                    if (this.flagRect) {
                        this.drawControls(this.imageCtx);
                        this.drawControls(this.circularCtx);
                    }
                }

                drawControls(ctx) {
                    if (!this.flagRect) return;

                    const { x, y, w, h, cx, cy } = this.flagRect;
                    const angle = this.flagRotation * Math.PI / 180;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);

                    // è®¡ç®—å››ä¸ªè§’åœ¨é¢„è§ˆç”»å¸ƒä¸Šçš„åæ ‡
                    const corners = [
                        { x: -w/2, y: -h/2 },
                        { x:  w/2, y: -h/2 },
                        { x:  w/2, y:  h/2 },
                        { x: -w/2, y:  h/2 }
                    ].map(p => {
                        const rx = p.x * cos - p.y * sin + cx;
                        const ry = p.x * sin + p.y * cos + cy;
                        return this.processToPreview(rx, ry);
                    });

                    ctx.save();
                    // ç”»è™šçº¿è¾¹æ¡†ï¼Œå¦‚æœä¸­å¿ƒæ¿€æ´»å°±å˜çº¢ã€‚å˜çº¢ï¼Œè¿™å°±è¯´æ˜ä½ çš„ç¯å¢ƒæœ‰é—®é¢˜è‡ªå·±å»é€‚é…
                    ctx.strokeStyle = this.activeControl === 'center' ? 'red' : '#007bff';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(corners[0].x, corners[0].y);
                    for (let i = 1; i < corners.length; i++) ctx.lineTo(corners[i].x, corners[i].y);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // ä¸­å¿ƒæ§åˆ¶ç‚¹
                    const centerPreview = this.processToPreview(cx, cy);
                    this.controlPoints.center = centerPreview;
                    ctx.beginPath();
                    ctx.arc(centerPreview.x, centerPreview.y, 8, 0, 2*Math.PI);
                    ctx.fillStyle = this.activeControl === 'center' ? 'red' : 'rgba(0,123,255,0.8)';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // ç¼©æ”¾ç‚¹ï¼ˆå³ä¸Šè§’ï¼‰
                    const scalePreview = corners[1];
                    this.controlPoints.scale = scalePreview;
                    ctx.beginPath();
                    ctx.arc(scalePreview.x, scalePreview.y, 8, 0, 2*Math.PI);
                    ctx.fillStyle = this.activeControl === 'scale' ? 'red' : 'rgba(255,0,0,0.9)';
                    ctx.fill();
                    ctx.stroke();

                    // æ—‹è½¬æ‰‹æŸ„ï¼ˆé¡¶éƒ¨ä¸­ç‚¹å‘å¤–å»¶ä¼¸ï¼‰
                    const topMidRaw = { x: cx, y: cy - h/2 };
                    const topMidRotated = {
                        x: cx + (0)*cos - (-h/2)*sin,
                        y: cy + (0)*sin + (-h/2)*cos
                    };
                    const topMidPreview = this.processToPreview(topMidRotated.x, topMidRotated.y);
                    const handleLength = 30;
                    const handleEndRaw = {
                        x: topMidRotated.x + sin * (handleLength / this.getPreviewTransform().scale),
                        y: topMidRotated.y - cos * (handleLength / this.getPreviewTransform().scale)
                    };
                    const handleEndPreview = this.processToPreview(handleEndRaw.x, handleEndRaw.y);

                    ctx.beginPath();
                    ctx.moveTo(topMidPreview.x, topMidPreview.y);
                    ctx.lineTo(handleEndPreview.x, handleEndPreview.y);
                    ctx.strokeStyle = this.activeControl === 'rotate' ? 'red' : '#ff9800';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    this.controlPoints.rotate = handleEndPreview;
                    ctx.beginPath();
                    ctx.arc(handleEndPreview.x, handleEndPreview.y, 8, 0, 2*Math.PI);
                    ctx.fillStyle = this.activeControl === 'rotate' ? 'red' : 'rgba(255,152,0,0.9)';
                    ctx.fill();
                    ctx.stroke();

                    ctx.restore();
                }

                getControlPoint(x, y) {
                    if (!this.controlPoints.center) return null;
                    const threshold = 15; // ç‚¹ä¸­æ§åˆ¶ç‚¹çš„è¯¯å·®èŒƒå›´
                    for (let key of ['scale', 'rotate', 'center']) {
                        const pt = this.controlPoints[key];
                        if (pt && Math.hypot(x - pt.x, y - pt.y) <= threshold) return key;
                    }
                    // å¦‚æœç‚¹é è¿‘ä¸­å¿ƒä¸€å®šèŒƒå›´ï¼Œä¹Ÿè§†ä¸ºä¸­å¿ƒæ‹–åŠ¨æ²¡æ‹–åŠ¨æˆ–è€…æ‹–ä¸åŠ¨å°±è‡ªå·±ä¿®æ”¹ä¸è¿‡è¦æ³¨æ„æ¨¡å—åŒ–ã€‚æ²¡æ¨¡å—åŒ–å†å†™çš„è¿™ä¹ˆçƒ‚è‡ªå·±å»å¤„ç†
                    if (this.flagRect) {
                        const distToCenter = Math.hypot(x - this.controlPoints.center.x, y - this.controlPoints.center.y);
                        if (distToCenter < 60) return 'center';
                    }
                    return null;
                }

                // ---------- é¼ æ ‡äº‹ä»¶ï¼ˆè¿™ä¸ªåŠŸèƒ½æˆ‘æ²¡æœ‰æ”¹åŠ¨ï¼Œè¿˜æ˜¯åŸæ ·ï¼‰----------
                handleMouseDown(e) {
                    if (!this.originalImage) return;
                    e.preventDefault();
                    const rect = e.target.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    this.activeControl = this.getControlPoint(x, y);
                    if (!this.activeControl) return;

                    this.isDragging = true;
                    this.lastMouse = { x, y };
                    this.dragStartState = {
                        flagOffset: { ...this.flagOffset },
                        flagScale: this.flagScale,
                        flagRotation: this.flagRotation
                    };

                    if (this.activeControl === 'center') e.target.style.cursor = 'move';
                    else if (this.activeControl === 'scale') e.target.style.cursor = 'nwse-resize';
                    else if (this.activeControl === 'rotate') e.target.style.cursor = 'crosshair';
                    this.drawAll();
                }

                handleMouseMove(e) {
                    if (!this.isDragging || !this.activeControl) return;
                    e.preventDefault();

                    const rect = e.target.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;

                    const deltaX = currentX - this.lastMouse.x;
                    const deltaY = currentY - this.lastMouse.y;
                    const t = this.getPreviewTransform();

                    if (this.activeControl === 'center') {
                        const dx = deltaX / t.scale;
                        const dy = deltaY / t.scale;
                        this.flagOffset.x = this.dragStartState.flagOffset.x + dx;
                        this.flagOffset.y = this.dragStartState.flagOffset.y + dy;
                    } else if (this.activeControl === 'scale') {
                        const center = this.controlPoints.center;
                        const startDist = Math.hypot(this.lastMouse.x - center.x, this.lastMouse.y - center.y);
                        const currentDist = Math.hypot(currentX - center.x, currentY - center.y);
                        if (startDist > 0) {
                            const ratio = currentDist / startDist;
                            this.flagScale = this.dragStartState.flagScale * ratio;
                            this.flagScale = Math.min(3.0, Math.max(0.5, this.flagScale));
                            this.scaleSlider.value = this.flagScale;
                            this.scaleInput.value = this.flagScale.toFixed(2);
                        }
                    } else if (this.activeControl === 'rotate') {
                        const center = this.controlPoints.center;
                        const startAngle = Math.atan2(this.lastMouse.y - center.y, this.lastMouse.x - center.x);
                        const currentAngle = Math.atan2(currentY - center.y, currentX - center.x);
                        let angleDelta = (currentAngle - startAngle) * 180 / Math.PI;
                        let newRotation = this.dragStartState.flagRotation + angleDelta;
                        this.flagRotation = Math.min(360, Math.max(0, newRotation));
                        this.rotationSlider.value = this.flagRotation;
                        this.rotationInput.value = this.flagRotation;
                    }

                    this.lastMouse = { x: currentX, y: currentY };
                    this.drawAll();
                    this.deferredSaveState();
                }

                handleMouseUp(e) {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.activeControl = null;
                        this.imageCanvas.style.cursor = 'pointer';
                        this.circularCanvas.style.cursor = 'pointer';
                        this.drawAll();
                        this.saveState();
                    }
                }

                // ------è§¦æ‘¸----------
                handleTouchStart(e) {
                    if (!this.originalImage) return;
                    e.preventDefault();

                    const touch = e.touches[0];
                    if (!touch) return;

                    this.touchCanvas = e.target;
                    const rect = this.touchCanvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;

                    this.touchActive = true;
                    this.touchLast = { x, y };
                    this.activeControl = 'center'; // è§¦æ‘¸æ—¶å¼ºåˆ¶é«˜äº®ä¸­å¿ƒï¼Œè®©è™šçº¿å˜çº¢
                    this.drawAll();
                }

                handleTouchMove(e) {
                    if (!this.touchActive || !this.touchCanvas) return;
                    e.preventDefault();

                    const touch = e.touches[0];
                    if (!touch) return;

                    const rect = this.touchCanvas.getBoundingClientRect();
                    const currentX = touch.clientX - rect.left;
                    const currentY = touch.clientY - rect.top;

                    const deltaX = currentX - this.touchLast.x;
                    const deltaY = currentY - this.touchLast.y;
                    const t = this.getPreviewTransform();

                    // å¢é‡æ›´æ–°ï¼šåœ¨å½“å‰ flagOffset ä¸Šç´¯åŠ ä½ç§»ï¼ˆè¿™æ ·å°±ä¸ä¼šå›å¼¹äº†ï¼‰
                    this.flagOffset.x += deltaX / t.scale;
                    this.flagOffset.y += deltaY / t.scale;

                    this.touchLast = { x: currentX, y: currentY };
                    this.drawAll();
                    this.deferredSaveState();
                }

                handleTouchEnd(e) {
                    if (this.touchActive) {
                        this.touchActive = false;
                        this.touchCanvas = null;
                        this.activeControl = null;
                        this.drawAll();
                        this.saveState();
                    }
                }
                // ---------- è§¦æ‘¸äº‹ä»¶ç»“æŸ ----------

                saveState(initial = false) {
                    const state = {
                        flagOffset: { ...this.flagOffset },
                        flagScale: this.flagScale,
                        flagRotation: this.flagRotation,
                        currentFlagKey: this.currentFlagKey
                    };
                    // å¦‚æœä¸ä¸Šä¸€ä¸ªçŠ¶æ€å‡ ä¹ç›¸åŒï¼Œå°±ä¸ä¿å­˜ã€ä¿å­˜äº†ä¹Ÿè´¹äº‹
                    if (this.history.length > 0) {
                        const last = this.history[this.historyIndex];
                        if (last &&
                            Math.abs(last.flagScale - state.flagScale) < 0.01 &&
                            Math.abs(last.flagRotation - state.flagRotation) < 1 &&
                            Math.abs(last.flagOffset.x - state.flagOffset.x) < 1 &&
                            Math.abs(last.flagOffset.y - state.flagOffset.y) < 1 &&
                            last.currentFlagKey === state.currentFlagKey) {
                            return;
                        }
                    }
                    // å¦‚æœå½“å‰ä¸æ˜¯æœ€æ–°ï¼Œè¯´æ˜æœ‰æ’¤é”€æ“ä½œï¼Œè£å‰ªæ‰åé¢çš„
                    if (this.historyIndex < this.history.length - 1) {
                        this.history = this.history.slice(0, this.historyIndex + 1);
                    }
                    this.history.push(state);
                    if (this.history.length > this.maxHistory) this.history.shift();
                    this.historyIndex = this.history.length - 1;
                }

                deferredSaveState() {
                    if (this.saveTimer) clearTimeout(this.saveTimer);
                    this.saveTimer = setTimeout(() => this.saveState(), 300);
                }

                loadState(state) {
                    this.flagOffset = { ...state.flagOffset };
                    this.flagScale = state.flagScale;
                    this.flagRotation = state.flagRotation;
                    if (state.currentFlagKey !== this.currentFlagKey) {
                        this.currentFlagKey = state.currentFlagKey;
                        const template = FLAG_TEMPLATES.find(t => t.key === state.currentFlagKey);
                        if (template) {
                            loadFlagImage(state.currentFlagKey, (img) => {
                                if (img) this.flagImage = img;
                                else this.flagImage = null;
                                this.renderFlagGallery();
                                this.drawAll();
                            });
                        }
                    }
                    this.scaleSlider.value = this.flagScale;
                    this.scaleInput.value = this.flagScale.toFixed(2);
                    this.rotationSlider.value = this.flagRotation;
                    this.rotationInput.value = this.flagRotation;
                    this.drawAll();
                }

                handleKeyDown(e) {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'z') { // æ’¤é”€
                            e.preventDefault();
                            if (this.historyIndex > 0) {
                                this.historyIndex--;
                                this.loadState(this.history[this.historyIndex]);
                            }
                        } else if (e.key === 'y') { // é‡åš
                            e.preventDefault();
                            if (this.historyIndex < this.history.length - 1) {
                                this.historyIndex++;
                                this.loadState(this.history[this.historyIndex]);
                            }
                        }
                    }
                }

                downloadImage() {
                    if (!this.originalImage) return;
                    const link = document.createElement('a');
                    link.download = this.originalFileName + '_flag.png';
                    link.href = this.processCanvas.toDataURL('image/png');
                    link.click();
                }

                fetchContributors() {
                    const repo = 'bghtnya/TransFlag_Avatar_Tool';
                    const url = `https://api.github.com/repos/${repo}/contributors`;
                    this.contributorsContainer.innerHTML = '<h3>é¡¹ç›®è´¡çŒ®è€…</h3><p>æ­£åœ¨åŠ è½½...</p>';
                    fetch(url)
                        .then(res => res.ok ? res.json() : Promise.reject())
                        .then(data => {
                            const users = data.filter(c => c.type === 'User');
                            if (users.length === 0) throw new Error();
                            const html = users.map(c => `
                                <li class="contributor-item">
                                    <img src="${c.avatar_url}" alt="${c.login}" class="contributor-avatar">
                                    <a href="${c.html_url}" target="_blank" class="contributor-login">${c.login}</a>
                                </li>
                            `).join('');
                            this.contributorsContainer.innerHTML = `<h3>é¡¹ç›®è´¡çŒ®è€…</h3><ul class="contributor-list">${html}</ul>`;
                        })
                        .catch(() => {
                            this.contributorsContainer.innerHTML = '<h3>é¡¹ç›®è´¡çŒ®è€…</h3><p>æ— æ³•åŠ è½½è´¡çŒ®è€…ï¼Œè¯·è®¿é—®ä»“åº“æŸ¥çœ‹ã€‚</p>';
                        });
                }
            }

            new FlagAvatarEditor(); // å¯åŠ¨ï¼å¦ˆçš„ç»ˆäºå†™å®Œäº†åˆ«ä»–å¦ˆå†çé¸¡å·´ä¹±æäº†
        })();
    </script>
</body>
</html>